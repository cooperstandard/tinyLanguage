-- Monadic Parsing
--   From Programming in Haskell by Graham Hutton

--    A Parser for things
-- Is a function from strings
--     To lists of pairs
--   Of things and strings

module MonadicParserLibrary where

   import Control.Applicative
   import Data.Char 

   -- Declare a new type for Parser
   --   This allows the Parser type to be an instance of a class
   --   The constructor P is a "dummy" constructor and serves no real purpose.
   newtype Parser a = P (String -> [(a, String)])

   -- parse
   --   Consume a Parser and a String
   --   Produce the result of apply the parser p to the given string
   parse :: Parser a -> String -> [(a, String)]
   parse (P p) input = p input

   -- item
   --   Consume a Parser and a character
   --   Produce a list with the character as the first value upon success and
   --      the empty list upon failure
   item :: Parser Char
   item = P (\input -> case input of
                            [] -> []
                            (x:xs) -> [(x,xs)])


   -- the Parser type is a Functor
   --   First step toward allowing Parsers to be sequenced
   --   apply a function g to the result value of a Parser if the parser
   --     succeeds or propagate failure otherwise
   --   Examples: 
   --     parse (fmap toUpper item) "abc" ==> [('A',"bc")]
   --     parse (fmap toUpper item) ""    ==> []
   instance Functor Parser where
      -- fmap :: (a -> b) -> Parser a -> Parser b
      fmap g p = P (\inp -> case parse p inp of
                                 [] -> []
                                 [(v,out)] -> [(g v, out)])

   -- the Parser type is Applicative
   --    pure transforms a value into a parser which always succeeds 
   --         with value as the result and does not consume input
   --         Example: parse (pure 1) "abc" ==> [(1,"abc")]
   --    <*> starts with a parse that returns a function
   --        next takes a parser which returns an argument
   --        produces a parser that produces the result of applying
   --        the function to the argument and only succeeds if all 
   --        components succeed
   --        Example: three :: Parser (Char,Char)
   --                 three = pure g <*> item <*> item <*> item
   --                         where g x y z = (x,z)
   --                 parse three "abcdef" ==> [(('a,','c'),"def")]
   --                 parse three "ab" ==> []
   instance Applicative Parser where
     -- pure :: a -> Parser a
     pure v = P (\inp -> [(v,inp)])

     -- <*> :: Parser (a -> b) -> Parser a -> Parser b
     pg <*> px = P (\inp -> case parse pg inp of
                                 [] -> []
                                 [(g,out)] -> parse (fmap g px) out)

   -- the Parser type is a Monad
   --   This will allow do notation
   --     Example: three :: Parser (Char,Char)
   --              three = do x <- item
   --                      item
   --                      z <- item
   --                      return (x,z)
   --     Note that return is another name for pure which builds parsers
   --          that always succeed.
   instance Monad Parser where
     -- (>>=) :: Parser a -> (a -> Parser b) -> Parser b
     p >>= f = P (\inp -> case parse p inp of
                               [] -> []
                               [(v,out)] -> parse (f v) out)

   -- the Parser type is an Alternative
   --     Examples: parse empty "abc" ==> []
   --               parse (empty <|> return 'd') "abc" ==> [('d',"abc")]
   instance Alternative Parser where
     -- empty :: Parser a
     empty = P (\inp -> [])

     -- (<|>) :: Parser a -> Parser a -> Parser a
     p <|> q = P (\inp -> case parse p inp of
                               [] -> parse q inp
                               [(v,out)] -> [(v,out)])

   -- Parser which satisfies a predicate
   sat :: (Char -> Bool) -> Parser Char
   sat pred = do x <- item
                 if pred x then return x else empty

   digit :: Parser Char
   digit = sat isDigit

   lower :: Parser Char
   lower = sat isLower

   upper :: Parser Char
   upper = sat isUpper

   letter :: Parser Char
   letter = sat isAlpha

   alphanum :: Parser Char
   alphanum = sat isAlphaNum

   char :: Char -> Parser Char
   char x = sat (==x)

   -- Example: parse (string "abc") "abcdef"  ==> [("abc", "def")]
   string :: String -> Parser String
   string [] = return []
   string (x:xs) = do char x
                      string xs
                      return (x:xs)

   ident :: Parser String
   ident = do x <- lower
              xs <- many alphanum
              return (x:xs)

   nat :: Parser Integer 
   nat = do xs <- some digit
            return (read xs)

   space :: Parser ()
   space = do many (sat isSpace)
              return ()

   int :: Parser Integer
   int = do char '-'
            n <- nat
            return (-n)
          <|> nat

   token :: Parser a -> Parser a
   token p = do space
                v <- p
                space
                return v

   identifier :: Parser String
   identifier = token ident

   natural :: Parser Integer 
   natural = token nat

   integer :: Parser Integer
   integer = token int 

   symbol :: String -> Parser String
   symbol xs = token (string xs)

   -- Example:
   -- Parse a list of natural numbers
   listOfNats :: Parser [Integer]
   listOfNats = do symbol "["
                   n <- natural
                   ns <- many (do symbol "," 
                                  natural)
                   symbol "]"
                   return (n:ns)
   
   expr :: Parser Integer
   expr = do t <- term
             do symbol "+"
                e <- expr
                return (t+e)
              <|> return t

   term :: Parser Integer 
   term = do f <- factor 
             do symbol "*"
                t <- term
                return (f*t)
              <|> return f

   factor :: Parser Integer
   factor = do symbol "("
               e <- expr
               symbol ")"
               return e
             <|> natural

   eval :: String -> Integer
   eval xs = case (parse expr xs) of
                [(n, [])] -> n
                [(_,out)] -> error ("Unused input " ++ out)
                []        -> error "Invalid input"


module TinyParser where

--    A Parser for things
-- Is a function from strings
--     To lists of pairs
--   Of things and strings

import TinyDefinitions
import TinyLexer

import MonadicParserLibrary
import Control.Applicative 

-- parseString
--   Consume a string containing a Tiny Language program 
--   Produce a structure representing the parse tree of the program 
-- parseString :: String -> [(ParseTree,String)]
parseString :: String -> ParseTree 
parseString program = let [(tree,remainingChars)] = parse expressionParser program
                          in
                             case remainingChars of 
                                  "" -> tree
                                  _ -> error ("Parse Error: " ++ remainingChars)

-- expressionParser
--   Produce a parser for an expression in the Tiny Language
--     The parser will produce a ParseTree representing the 
--         program 

-- TODO: Most of the expression forms below are missing ( ).

expressionParser :: Parser ParseTree  
expressionParser = do boolExpr <- boolLevelOne   
                      return boolExpr 
                    <|>
                   do mathExpr <- mathLevelOne
                      return mathExpr
                    <|>
-- TODO: Add parsing for a Pair value here (i.e. (pair expression expression) )
                    -- <|> 
                   do letKeyword
                      i <- ident
                      equalKeyword
                      expr <- expressionParser 
                      inKeyword
                      body <- expressionParser
                      return (LetNode i expr body)
                    <|> 
-- TODO: Add parsing for a lambda expression here
                    -- <|>
                   do callKeyword
                      i <- ident
                      body <- expressionParser
                      return (CallNode i body)

-- Lowest level of precedence of Boolean Expressions 
--    This handles the boolean or operation
boolLevelOne :: Parser ParseTree 
boolLevelOne = do exprOne <- boolLevelTwo
                  do op <- orOp
                     exprTwo <- expressionParser 
                     return (OrNode exprOne exprTwo)
                    <|>
                     return exprOne 

-- Second level of precedence of Boolean Expressions
--    This handles the boolean and operation 
boolLevelTwo :: Parser ParseTree
boolLevelTwo = do exprOne <- boolLevelThree
                  do op <- andOp
                     exprTwo <- expressionParser
                     return (AndNode exprOne exprTwo)
                    <|>
                     return exprOne

-- TODO: Add parsing for the second level of boolean precedence. This level
--       only contains andOp. This is called by boolLevelOne and should call
--       boolLevelThree below.

-- Third level of precedence of Boolean Expressions
--     This handles the boolean not operation
boolLevelThree :: Parser ParseTree
boolLevelThree = do op <- notOp
                    expr <- expressionParser
                    return (NotNode expr)
                  <|>
                 do leftParenthesis
                    expr <- expressionParser
                    rightParenthesis
                    return expr
                  <|>
                 do b <- boolConst 
                    return b     

-- Lowest level of precedence of Math Expressions 
--    This handles the math add and subtract operations

-- TODO: add parsing for mathLevelOne

-- Lowest level of precedence of Math Expressions 
--    This handles the math multiplication, division and remainder operations
mathLevelTwo :: Parser ParseTree 
mathLevelTwo = do exprOne <- mathLevelThree
                  do op <- multiplyOp
                     exprTwo <- expressionParser 
                     return (MultiplicationNode exprOne exprTwo)
                   <|> do op <- divideOp
                          exprTwo <- expressionParser
                          return (DivisionNode exprOne exprTwo) 
                   <|>
                     return exprOne
    
-- Third level of precedence of Math Expressions
--     This handles parenthesis
mathLevelThree :: Parser ParseTree
mathLevelThree = do leftParenthesis
                    expr <- expressionParser
                    rightParenthesis
                    return expr
                  <|> do num <- integerConst  
                         return num


module TinyDefinitions where

  -- TODO: Add Nodes for Addition, Subtraction, Multiplication, Division, Remainder
  data ParseTree = AndNode ParseTree ParseTree |
                   OrNode ParseTree ParseTree  |
                   NotNode ParseTree           |
                   ValueNode ValueType         |
                   IdNode String               |
                   LetNode String ParseTree ParseTree |
                   LambdaNode String ParseTree |
                   CallNode String ParseTree |
                   AdditionNode ParseTree ParseTree |
                   SubtractionNode ParseTree ParseTree |
                   MultiplicationNode ParseTree ParseTree |
                   DivisionNode ParseTree ParseTree |
                   RemainderNode ParseTree ParseTree |
                   EmptyNode
                    deriving (Show)
  
  -- closure structure

  data ClosureStructure = Closure String ParseTree EnvType 
                          deriving (Show)

  -- TODO: Add IntegerType and PairType below
  data ValueType = BoolType Bool | 
                   IntegerType Integer |
                   PairType ValueType ValueType | -- is this right?
                   ClosureType ClosureStructure
                     deriving (Show)
  


  type EnvType = [(String,ValueType)]



module Env where

  emptyEnv = []

  extendEnv :: (a,b) -> [(a,b)] -> [(a,b)]
  extendEnv (key,val) env = (key,val):env

  applyEnv :: (Eq a) => a -> [(a,b)] -> b
  applyEnv k [] = error "Variable undefined"
  applyEnv k ((key,val):kvs) = if k == key
                                 then val
                                 else (applyEnv k kvs)

  emptyEnv' = \k -> error "Variable undefined"

  extendEnv' (key,val) fenv = \k -> if k == key
                                       then val
                                       else (fenv key)

  applyEnv' k fenv = fenv k


module TinyLexer where

import Control.Applicative 
import MonadicParserLibrary 

import TinyDefinitions

-- Build monadic parsers for each of the words in the Tiny
--   Language 

trueConst :: Parser ParseTree 
trueConst = do symbol "true"
               return (ValueNode (BoolType True))

falseConst :: Parser ParseTree 
falseConst = do symbol "false"
                return (ValueNode (BoolType False))

boolConst :: Parser ParseTree 
boolConst = do trueConst 
             <|> falseConst

andOp :: Parser String
andOp = symbol "and"

orOp :: Parser String
orOp = symbol "or"

notOp :: Parser String
notOp = symbol "not"

boolOp :: Parser String
boolOp = do andOp
           <|> orOp
           <|> notOp 

-- TODO: Add parser definitions for leftParenthesis and rightParenthesis


-- TODO: Add parser definitions for addOp, subtractOp, multiplyOp
--           divideOp, and remainderOp


mathOp :: Parser String
mathOp = do addOp
          <|> subtractOp
          <|> multiplyOp
          <|> divideOp
          <|> remainderOp

integerConst :: Parser ParseTree
integerConst = do num <- integer
                  return (ValueNode (IntegerType num))

equalKeyword :: Parser String
equalKeyword = symbol "equals"

callKeyword :: Parser String
callKeyword = symbol "call"

inKeyword :: Parser String
inKeyword = symbol "in"

lambdaKeyword :: Parser String
lambdaKeyword = symbol "lambda"

letKeyword :: Parser String
letKeyword = symbol "let"


module TinyEvaluator where

import TinyParser
import TinyLexer
import Env

import TinyDefinitions

-- compileAndRun
--   Consumes a String which is the program
--   Produces the result of lexing, parsing, and evaluating the program
compileAndRun :: String -> ValueType
compileAndRun program = evaluate (parseString program) emptyEnv

-- evaluate
--   Consume a Parse Tree
--   Produce the result value of evaluating the given Parse Tree
evaluate :: ParseTree -> EnvType -> ValueType 
evaluate tree env = case tree of
                      (ValueNode (BoolType val)) -> BoolType val
                      (ValueNode (ClosureType val)) -> ClosureType val
-- TODO: Add ValueNode which contains IntegerType
-- TODO: Add ValueNode which contains PairType
                      (IdNode var) -> (applyEnv var env)
                      (NotNode val) -> let param = (evaluate val env)
                                       in 
                                            case param of 
                                               (BoolType True) -> (BoolType False)
                                               (BoolType False) -> (BoolType True)
                      (AndNode valOne valTwo) -> let paramOne = (evaluate valOne env)
                                                     paramTwo = (evaluate valTwo env)
                                                   in
                                                     case paramOne of 
                                                        (BoolType True) -> 
                                                           case paramTwo of
                                                             (BoolType True) -> (BoolType True)
                                                             (BoolType False) -> (BoolType False)
                                                        (BoolType False) -> (BoolType False)
                      (OrNode valOne valTwo) -> let paramOne = (evaluate valOne env)
                                                    paramTwo = (evaluate valTwo env)
                                                  in
                                                    case paramOne of
                                                       (BoolType True) -> (BoolType True)
                                                       (BoolType False) ->
                                                           case paramTwo of
                                                                (BoolType True) -> (BoolType True)
                                                                (BoolType False) -> (BoolType False)
-- TODO: Add evaluation of all the Mathematical Operations
                      (LetNode id val body) -> let valResult = (evaluate val env)
                                                           in 
                                                             (evaluate body 
                                                               (extendEnv (id,valResult) env))
                      (LambdaNode id body) -> ClosureType (Closure id body env)
                      (CallNode functionName expr) -> 
                           let result = applyEnv functionName env
                              in 
                                case result of
                                    ClosureType (Closure paramName functionBody functionEnv) ->
                                         (evaluate functionBody 
                                              (extendEnv (paramName, (evaluate expr env)) functionEnv))
                                    _ -> error "Illegal function call"
                   
